package main

import (
	"fmt"
	"strings"
	"text/template"
)

var (
	appGen = `/**
  app_gen.h, James Condron {{ .Year }}

  DO NOT EDIT - THIS FILE IS AUTOGENERATED

  Return paged records data for the menu to show
 **/

#ifndef RECORDS_COUNT
#define RECORDS_COUNT {{ len .Items }}
#endif

char *records[RECORDS_COUNT] = {
  {{ range .Items }}"{{.Case}}{{.Pos}}: {{.Artist}}: {{.Title}}",{{ end }}
};

char *tracks[RECORDS_COUNT] = {
  {{ range .Items }}"{{ tracks .Tracks}}",{{ end }}
};

static inline int _len(*char s) {
  int l = 0;
  while(s[l] != '\0') {
    l++;
  }
  return l;
}

static inline char* record_name(int line) {
  if (line > RECORDS_COUNT) {
    line = RECORDS_COUNT;
  }

  return records[line];
}

static inline char* record_track_offset(int line, int start, char *buffer) {
  if (line > RECORDS_COUNT) {
    line = RECORDS_COUNT;
  }

  char *track = tracks[line];

  int i = 0;
  int max = start + 80;

  if (max > _len(track)) {
    max = _len(track);
  }

  for (int pos = start; pos < max; pos++) {
    buffer[i] = track[pos];
    i++;
  }

  buffer[i] = '\0';

  return buffer;
}
`
)

var funcMap = template.FuncMap{
	"tracks": func(tracks []Track) string {
		if len(tracks) == 0 {
			return "Track listing unknown for this title"
		}

		sA := make([]string, len(tracks))

		for idx, t := range tracks {
			// Screen is only big enough for 20, and we're not
			// going to bother writing a pager
			if idx > 19 {
				break
			}

			sA[idx] = fmt.Sprintf(`%s - %s`, t.Track, t.Title)
		}

		return strings.Join(sA, ", ")
	},
}

type Templater struct {
	Year  int
	Items []Record
}

func (t Templater) Template() (output string, err error) {
	sb := &strings.Builder{}
	tmpl, err := template.New("appGen").Funcs(funcMap).Parse(appGen)
	if err != nil {
		return
	}

	err = tmpl.Execute(sb, t)
	if err != nil {
		return
	}

	return sb.String(), nil
}
